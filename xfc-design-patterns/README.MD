## 设计模式
### 工厂模式
#### 简单工厂模式(https://www.processon.com/view/link/5f9d15eee0b34d03d7f1d953)
> 工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用 （即使用 new运算符）。 不用担心， 对象仍将通过 new运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。
* 概念
    * 产品 （Product）： 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。
    * 具体产品 （Concrete Products）： 是产品接口的不同实现。
    * 创建者 （Creator）： 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。
      注意， 尽管它的名字是创建者， 但他最主要的职责并不是创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。
    * 具体创建者 （Concrete Creators）： 将会重写基础工厂方法， 使其返回不同类型的产品。 注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。
* 使用场景
    * 当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。
    * 如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。
    * 如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。
* 优缺点
    * 优点
        * 你可以避免创建者和具体产品之间的紧密耦合
        * 单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。
        * 开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。
    * 缺点
        * 应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 **最好的情况是将该模式引入创建者类的现有层次结构中**。
* 跟其他模式的关系
    * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。
    * 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。
    * 你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。
    * 原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。
    * 工厂方法是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。

#### 抽象工厂模式（https://www.processon.com/view/link/5f9d2940e0b34d03d7f1fc56）
* 概念
    * 抽象工厂模式是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。
    * 工厂的创建：如果客户端仅接触抽象接口， 那么谁来创建实际的工厂对象呢？ 一般情况下， 应用程序会在初始化阶段创建具体工厂对象。 而在此之前， 应用程序必须根据配置文件或环境设定选择工厂类别。
* 使用场景
    * 如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。
    > 抽象工厂为你提供了一个接口， 可用于创建每个系列产品的对象。 只要代码通过该接口创建对象， 那么你就不会生成与应用程序已生成的产品类型不一致的产品。
    * 如果你有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。
    > 在设计良好的程序中， 每个类仅负责一件事。 如果一个类与多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。                          
* 实现方法
    * 以不同的产品类型与产品变体为维度绘制矩阵。
    * 为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口。
    * 声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法。
    * 为每种产品变体实现一个具体工厂类。
    * 在应用程序中开发初始化代码。 该代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对象传递给所有需要创建产品的类。
    * 找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。
* 优缺点
    * 优点    
        * 你可以确保同一工厂生成的产品相互匹配。
        * 你可以避免客户端和具体产品代码的耦合。
        * 单一职责原则。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。
        * 开闭原则。 向应用程序中引入新产品变体时， 你无需修改客户端代码。                                                                 
    * 缺点
        * 由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。
* 跟其他模式的关系
    * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。
    * 生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。
    * 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。
    * 当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂来代替外观模式。
    * 你可以将抽象工厂和桥接模式搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。
    * 抽象工厂、 生成器和原型都可以用单例模式来实现。
#### 生成器模式(构建者模式https://www.processon.com/view/link/5f9d4453e401fd4885446c6d)
* 概念
    * 生成器模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。
    * 生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为生成器的独立对象中。
    * 生成器 （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。
    * 具体生成器 （Concrete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。
    * 产品 （Products） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。
    * 主管 （Director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。
    * 客户端 （Client） 必须将某个生成器对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的生成器。
* 使用场景
    * 使用生成器模式可避免 “重叠构造函数 （telescopic constructor）” 的出现。
       假设你的构造函数中有十个可选参数， 那么调用该函数会非常不方便； 因此， 你需要重载这个构造函数， 新建几个只有较少参数的简化版。 但这些构造函数仍需调用主构造函数， 传递一些默认数值来替代省略掉的参数。
       class Pizza {
          Pizza(int size) { ... }
          Pizza(int size, boolean cheese) { ... }
          Pizza(int size, boolean cheese, boolean pepperoni) { ... }
          // ...
       只有在 C# 或 Java 等支持方法重载的编程语言中才能写出如此复杂的构造函数。
      生成器模式让你可以分步骤生成对象， 而且允许你仅使用必须的步骤。 应用该模式后， 你再也不需要将几十个参数塞进构造函数里了。
    * 当你希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时， 可使用生成器模式。
      如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。
      基本生成器接口中定义了所有可能的制造步骤， 具体生成器将实现这些步骤来制造特定形式的产品。 同时， 主管类将负责管理制造步骤的顺序。
    * 使用生成器构造组合树或其他复杂对象。
      生成器模式让你能分步骤构造产品。 你可以延迟执行某些步骤而不会影响最终产品。 你甚至可以递归调用这些步骤， 这在创建对象树时非常方便。
      生成器在执行制造步骤时， 不能对外发布未完成的产品。 这可以避免客户端代码获取到不完整结果对象的情况。
* 实现方法
    * 清晰地定义通用步骤， 确保它们可以制造所有形式的产品。 否则你将无法进一步实施该模式。
    * 在基本生成器接口中声明这些步骤。
    * 为每个形式的产品创建具体生成器类， 并实现其构造步骤。
    * 不要忘记实现获取构造结果对象的方法。 你不能在生成器接口中声明该方法， 因为不同生成器构造的产品可能没有公共接口， 因此你就不知道该方法返回的对象类型。 但是， 如果所有产品都位于单一类层次中， 你就可以安全地在基本接口中添加获取生成对象的方法。
    * 考虑创建主管类。 它可以使用同一生成器对象来封装多种构造产品的方式。
    * 客户端代码会同时创建生成器和主管对象。 构造开始前， 客户端必须将生成器对象传递给主管对象。 通常情况下， 客户端只需调用主管类构造函数一次即可。 主管类使用生成器对象完成后续所有制造任务。 还有另一种方式， 那就是客户端可以将生成器对象直接传递给主管类的制造方法。
    * 只有在所有产品都遵循相同接口的情况下， 构造结果可以直接通过主管类获取。 否则， 客户端应当通过生成器获取构造结果。
* 优缺点
    * 优点    
        * 你可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。
        * 生成不同形式的产品时， 你可以复用相同的制造代码。
        * 单一职责原则。 你可以将复杂构造代码从产品的业务逻辑中分离出来。                                                             
    * 缺点
        *  由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。
* 跟其他模式的关系
    * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。
    * 生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。
    * 你可以在创建复杂组合模式树时使用生成器， 因为这可使其构造步骤以递归的方式运行。
    * 你可以结合使用生成器和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。
    * 抽象工厂、 生成器和原型都可以用单例模式来实现。
#### 原型模式(构建者模式https://www.processon.com/view/link/5f9d4453e401fd4885446c6d)
* 概念
    * 原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。
    * 原型 （Prototype） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone克隆的方法。
    * 具体原型 （Concrete Prototype） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。
    * 客户端 （Client） 可以复制实现了原型接口的任何对象。
* 使用场景
    * 如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。
      这一点考量通常出现在代码需要处理第三方代码通过接口传递过来的对象时。 即使不考虑代码耦合的情况， 你的代码也不能依赖这些对象所属的具体类， 因为你不知道它们的具体信息。
      原型模式为客户端代码提供一个通用接口， 客户端代码可通过这一接口与所有实现了克隆的对象进行交互， 它也使得客户端代码与其所克隆的对象具体类独立开来。
    * 如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。
      在原型模式中， 你可以使用一系列预生成的、 各种类型的对象作为原型。
      客户端不必根据需求对子类进行实例化， 只需找到合适的原型并对其进行克隆即可。
* 实现方法
    * 创建原型接口， 并在其中声明 克隆方法。 如果你已有类层次结构， 则只需在其所有类中添加该方法即可。
    * 原型类必须另行定义一个以该类对象为参数的构造函数。 构造函数必须复制参数对象中的所有成员变量值到新建实体中。 如果你需要修改子类， 则必须调用父类构造函数， 让父类复制其私有成员变量值。
    * 如果编程语言不支持方法重载， 那么你可能需要定义一个特殊方法来复制对象数据。 在构造函数中进行此类处理比较方便， 因为它在调用 new运算符后会马上返回结果对象。
    * 克隆方法通常只有一行代码： 使用 new运算符调用原型版本的构造函数。 注意， 每个类都必须显式重写克隆方法并使用自身类名调用 new运算符。 否则， 克隆方法可能会生成父类的对象。
    * 你还可以创建一个中心化原型注册表， 用于存储常用原型。
    * 你可以新建一个工厂类来实现注册表， 或者在原型基类中添加一个获取原型的静态方法。 该方法必须能够根据客户端代码设定的条件进行搜索。 搜索条件可以是简单的字符串， 或者是一组复杂的搜索参数。 找到合适的原型后， 注册表应对原型进行克隆， 并将复制生成的对象返回给客户端。
    * 最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。
* 优缺点
    * 优点
        * 你可以克隆对象， 而无需与它们所属的具体类相耦合。
        * 你可以克隆预生成原型， 避免反复运行初始化代码。
        * 你可以更方便地生成复杂对象。
        * 你可以用继承以外的方式来处理复杂对象的不同配置。
    * 缺点
        * 克隆包含循环引用的复杂对象可能会非常麻烦。
* 跟其他模式的关系
    * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。
    * 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。
    * 原型可用于保存命令模式的历史记录。
    * 大量使用组合模式和装饰模式的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。
    * 原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。
    * 有时候原型可以作为备忘录模式的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。
    * 抽象工厂、 生成器和原型都可以用单例模式来实现。