# Spring源码学习q前置知识
##  Spring是什么（java应用框架）
*   是一个轻量级，面向Bean，松耦合，万能胶（能与主流框架无缝集成），设计模式（将java中的设计模式运用的淋漓尽致）
##  Spring设计初衷
*   Spring是为了解决企业级应用开发的复杂性而设计，他可以做很多事情，单归根结底是支撑Spring的仅仅是少许的基本理念。而所有的基本里面最终的一个根本使命就是"简化开发"
    *   Spring的四种策略
        *   基于POJO的轻量级和最小侵入性编程
        *   通过依赖注入和面向接口松耦合
        *   基于切面和惯性进行声明式编程
        *   通过切面和模版减少样板式代码
    *   她主要是通过：面向Bean，依赖注入和切面编程这三种方式来达成的
##   面向Bean编程
*   Spring是面向Bean的编程，Bean在Spring中才是真正的主角，Bean在Spring中的作用就像Object对OOP的意义一样，Spring中如果没有Bean也就没有Spring的意义，Spring提供了IOC容器通过配置文件或注解的方式来管理对象之间的依赖关系
*   Spring和核心概念
    *   控制反转(Inversion of Controller):控制对象的创建，最终目的是为了实现依赖注入
        *   依赖注入(Dependency inject):依赖注入
            *   @Autowired InterfaceA a;自动把它的实现类注入
            *   @Resource("beanName") InterfaceA a;IOC容器类的id对象自动注入到这里（可以支持父子类关系）
            *   @Autowired A a;可以注入普通类
        *   Spring的注入方式
            *   set方法
            *   构造方法
            *   强制赋值（暴力反射）
    *   AOP(面向切面编程):允许程序员对某个影响多个类行为的逻辑抽取出来作为一个模块嵌入到正常的业务代码中执行，可与实际业务进行松耦合。如日志管理，事物管理等。
        *   Spring中用到aop的地方
            *   Authentication 权限认证
            *   Logging 日志
            *   Transaction Manager 事务管理
            *   Lazy Loading 懒加载
            *   Context Process 上下文处理
            *   Error Handler 异常处理
            *   Cache 处理
##   常用的设计模式
*   代理模式，只关心过程，在正常的业务逻辑中嵌入公共逻辑
    *   JDK代理
        *   原理描述
            *   首先拿到被代理对象的引用，然后去获取它的接口
            *   JDK代理会重新生成一个类，同时实现我们给的代理对象所实现的接口
            *   把被代理对象的引用拿到
            *   重新生成一个java文件，并通过jdk自带的编译工具编译为class字节码文件
            *   通过来加载器家在到jvm
        *   适用场景(3个必要条件)
            *   两个角色：执行者，被代理对象
            *   注重过程，必须要做的事儿，但是被代理对象没有时间做或者不想做
            *   执行者必须拿到被代理对象的信息(执行者持有被代理对象的引用)
        *   总结：字节码重组
    *   Cglib代理
        *   原理描述
            *   cglib实现动态代理的方式是通过为被代理类创建子类类实现的，需要创建一个实现MethodInterceptor接口的方法拦截器，并重写intercept方法进行回调
                构建字节码文件，通过Enhancer对象设置回调类（回调类就是指实现了MethodInterceptor类的的对象），然后设置需要为其创建子类代理的父类，然后通过Enhancer实例的create方法进行穿件子类代理对象的字节码文件，通过create方法创建的代理类可以强转为被代理类的类型
            *   字节码文件生成方法解析：cglib是通过FastClass进行代理类的生成，cglib的代理是在**运行时**才生成的，而jdk代理是通过io写java文件，然后通过编译生成的
        *   使用场景
            *   代理可以在每一个方法调用前加一些代码，调用后加一些代码
            *   如AOP事务（声明式事务，如注解），日志监听
            *   cglib无法代理被关键字final修饰的类或者方法
        *   总结：字节码重组，cglib的代理类字节码文件生成方式有待**深究**
    *   JDK代理和cglib代理对比
        *   1.jdk的动态代理是通过接口来进行强制转换的，生成以后的代理对象，可以强转为接口类型
        *   2.CGlib的动态代理是通过生成被代理对象的子类，然后重写父类的方法，生成以后的对象，可以强制转换为被代理对象，也就是用自己写的类，多态（子类引用赋值给父类）
        *   3.JDK动态代理是实现了被代理对象的接口，Cglib是继承了被代理对象。
        *   4.JDK和Cglib都是在运行期生成字节码，JDK是直接写Class字节码，Cglib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低。
        *   5.JDK调用代理方法，是通过反射机制调用，Cglib是通过FastClass机制直接调用方法，Cglib执行效率更高。
        *   6.jdk,cglib会代理指定类的toString(),hashCode(),equals()方法
*   工厂模式：隐藏复杂的实现逻辑，只关心结果
    *   简单工厂模式：根据不同类型返回对应的实例对象（实际中不会使用）
        +   违背开闭原则
        +   简单抽象，减少用户创建实际操作对象，用户只需要知道类型就可以获取一个指定的对象
    *   工厂方法：定义一个创建对象的接口，但是由子类决定要实力化的是哪一个，工厂方法让类把实例化推迟到子类
        +   不违背开闭原则，扩展方便，对原来业务不侵入
        +   维护成本较高，每增加一种逻辑，就需要增加一个工厂
    *   抽象工厂：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类
    *   工厂方法和抽象工厂区别
        工厂方法模式： 只有一个抽象产品类，具体工厂类只能创建一个具体产品类的实例 
        抽象工厂模式： 有多个抽象产品类 ，具体工厂类能创建多个具体产品类的实例
*   单例模式
    *   特点
        *   保证从系统的启动到系统的终止，全过程只会产生一个实例对象
        *   当我们应用中遇到功能性冲突的时候，需要使用单例模式（判断这个类在多个对象使用时会产生冲突）
    *   7中实现方式
        *   匿名内部类（饿汉式）
            *   经典常用，线程安全，效率高，@See InnerSingleton类
            *   注意事项：内部类的实现需要使用final关键字修饰，<font color ="red">因为在cglib代理模式下，可能会存在引用地址会被修改，导致单例失效</font>
        *   双重判断（懒汉式）
            *   双重判断，并且需要使用synchronized关键字，效率低 @See Singleton
    *   类状态到jvm的过程
        +   从上往下（必须声明在前，使用在后）
        +   先属性，后方法
        +   先静态，后动态
*   委派模式:关心结果（不再java23中设计模式中）
    +   原理：调用方通过一个任务执行器进行任务分配，但是不关心执行器如何分配任务，只关心结果。而任务执行器将会根据每个实例对象的功能，进行任务分配。
    +   作用：基本作用就是负责任务的调用和分配任务，跟代理模式很像，可以看做是一种特殊情况下的静态代理的全权代理，但是代理模式注重过程，而委派模式注重结果
    +   使用场景：如老板，项目经理，员工之间的关系。老板将任务指派给项目经理，但是项目经理本身不会去完成任务内容，而是会指派给员工。但是老板只知道关心项目经理是否完成任务。这就是所谓的，活儿是我们干的，功劳是别人的。
    +   总结：
*   策略模式:关心过程，产生的结果是一样的
    *   原理描述
    *   使用场景
    *   总结
*   原型模式：过程相同，
    *   原理描述：就是一个现成的对象，这个对象里面已经有设置好的值，当我要新建一个对象，并且给新建的对象赋值，而且赋值内容一摸一样
    *   拷贝方式
        +   深拷贝：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。 
        +   浅拷贝：java的Object对象自带的clone方法就是一种浅拷贝，只支持9中，也就是java的4类八种基础数据类型，加上String类型的数据可以直接进行拷贝。 被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。 Object类提供的方法clone只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址
    *   作用：[查看示例代码](./xfc-spring-design-patterns/src/main/java/com/github/xfc/prototype/deep/ClonePrototypeDeep.java)
    *   使用场景：spring的对象作用域
    *   总结：原型模式拷贝的对象，不是通过调用构造方法进行创建的，而是通过ObjectInputStream 反序列化进行创建对象，关于对象的创建见[java中创建对象的5中不同的方法](http://www.importnew.com/22405.html)。反序列化时候，JAVA虚拟机都会为我们创建一个单独的对象。在反序列化中，JAVA虚拟机不会使用任何构造函数来创建对象，因此如果需要通过反序列化创建对象，需要是Serializable接口
*   模版模式：
    *   原理描述：
    *   作用：
    *   使用场景：

##  总结
------
|设计模式|应用场景|一句话总结|实际生活中的例子|
|:---:|:---:|:---:|:---:|
|代理模式|1,两个角色参与，一个被代理人，一个代理人（实际执行者).<br>2,对于被代理人来说，这件事是一定要做的，但是自己又不想做或者没时间做，需要找代理。<br>3,代理人必须要获取被代理人的资料（也就是被代理对象的引用）|办事要求人，所以找代理，关心过程|找房中介
|工厂模式|1,对调用者隐藏复杂的逻辑处理过程，调用者只关心结果|只对结果负责，不关心过程|造车工厂
|单例模式|1,保证系统从启动到终止只会产生一个对象。<br>2,当我们遇到两个功能性冲突的时候，需要使用单例模式|独一无二|直属领导就是单例模式
|委派模式|1,连个角色，一个委托人和被委托人。<br>2,委托人和被委托人在权利上是平等的（实现同一个接口）。<br>3,委托人持有被委托人的引用。<br>4,老板只关心结果，不关心过程|干活是你的，功劳是领导的。只关心结果，不关心过程|领导和员工
|策略模式|1,最终执行结果是固定的，但是每个策略执行过程不一样|我行我素|写代码风格，每个人都不一样，但是同一个功能结果一样
|原型模式|1,首先有个原型。<br>2,数据内容相同买单时对象实例不同|复制粘贴|克隆羊
|模版模式|1,执行流程一样，但是中间有些步骤有细微差别。<br>2,可实现批量生产|流程标准化，原料自己家|咖啡机，选完配料，可以得出不同的咖啡

------
<font color="#7FFFD4">深入Spring源码6 50分钟</font>
$\color{#FF0000}{深入Spring源码}$