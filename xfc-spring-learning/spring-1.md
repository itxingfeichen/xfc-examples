# Spring源码学习
##  Spring是什么（java应用框架）
*   是一个轻量级，面向Bean，松耦合，万能胶（能与主流框架无缝集成），设计模式（将java中的设计模式运用的淋漓尽致）
##  Spring设计初衷
*   Spring是为了解决企业级应用开发的复杂性而设计，他可以做很多事情，单归根结底是支撑Spring的仅仅是少许的基本理念。而所有的基本里面最终的一个根本使命就是"简化开发"
    *   Spring的四种策略
        *   基于POJO的轻量级和最小侵入性编程
        *   通过依赖注入和面向接口松耦合
        *   基于切面和惯性进行声明式编程
        *   通过切面和模版减少样板式代码
    *   她主要是通过：面向Bean，依赖注入和切面编程这三种方式来达成的
##   面向Bean编程
*   Spring是面向Bean的编程，Bean在Spring中才是真正的主角，Bean在Spring中的作用就像Object对OOP的意义一样，Spring中如果没有Bean也就没有Spring的意义，Spring提供了IOC容器通过配置文件或注解的方式来管理对象之间的依赖关系
*   Spring和核心概念
    *   控制反转(Inversion of Controller):控制对象的创建，最终目的是为了实现依赖注入
        *   依赖注入(Dependency inject):依赖注入
            *   @Autowired InterfaceA a;自动把它的实现类注入
            *   @Resource("beanName") InterfaceA a;IOC容器类的id对象自动注入到这里（可以支持父子类关系）
            *   @Autowired A a;可以注入普通类
        *   Spring的注入方式
            *   set方法
            *   构造方法
            *   强制赋值（暴力反射）
    *   AOP(面向切面编程):允许程序员对某个影响多个类行为的逻辑抽取出来作为一个模块嵌入到正常的业务代码中执行，可与实际业务进行松耦合。如日志管理，事物管理等。
        *   Spring中用到aop的地方
            *   Authentication 权限认证
            *   Logging 日志
            *   Transaction Manager 事务管理
            *   Lazy Loading 懒加载
            *   Context Process 上下文处理
            *   Error Handler 异常处理
            *   Cache 处理
##   常用的设计模式
*   代理模式，只关心过程，在正常的业务逻辑中嵌入公共逻辑
    *   JDK代理
        *   原理描述
            *   首先拿到被代理对象的引用，然后去获取它的接口
            *   JDK代理会重新生成一个类，同时实现我们给的代理对象所实现的接口
            *   把被代理对象的引用拿到
            *   重新生成一个java文件，并通过jdk自带的编译工具编译为class字节码文件
            *   通过来加载器家在到jvm
        *   适用场景(3个必要条件)
            *   两个角色：执行者，被代理对象
            *   注重过程，必须要做的事儿，但是被代理对象没有时间做或者不想做
            *   执行者必须拿到被代理对象的信息(执行者持有被代理对象的引用)
        *   总结：字节码重组
    *   Cglib代理
        *   原理描述
            *   cglib实现动态代理的方式是通过为被代理类创建子类类实现的，需要创建一个实现MethodInterceptor接口的方法拦截器，并重写intercept方法进行回调
                构建字节码文件，通过Enhancer对象设置回调类（回调类就是指实现了MethodInterceptor类的的对象），然后设置需要为其创建子类代理的父类，然后通过Enhancer实例的create方法进行穿件子类代理对象的字节码文件，通过create方法创建的代理类可以强转为被代理类的类型
            *   字节码文件生成方法解析：cglib是通过FastClass进行代理类的生成，cglib的代理是在**运行时**才生成的，而jdk代理是通过io写java文件，然后通过编译生成的
        *   使用场景
            *   代理可以在每一个方法调用前加一些代码，调用后加一些代码
            *   如AOP事务（声明式事务，如注解），日志监听
            *   cglib无法代理被关键字final修饰的类或者方法
        *   总结：字节码重组，cglib的代理类字节码文件生成方式有待**深究**
    *   JDK代理和cglib代理对比
        *   1.jdk的动态代理是通过接口来进行强制转换的，生成以后的代理对象，可以强转为接口类型
        *   2.CGlib的动态代理是通过生成被代理对象的子类，然后重写父类的方法，生成以后的对象，可以强制转换为被代理对象，也就是用自己写的类，多态（子类引用赋值给父类）
        *   3.JDK动态代理是实现了被代理对象的接口，Cglib是继承了被代理对象。
        *   4.JDK和Cglib都是在运行期生成字节码，JDK是直接写Class字节码，Cglib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低。
        *   5.JDK调用代理方法，是通过反射机制调用，Cglib是通过FastClass机制直接调用方法，Cglib执行效率更高。
        *   6.jdk,cglib会代理指定类的toString(),hashCode(),equals()方法
*   工厂模式：隐藏复杂的实现逻辑，只关心结果
    *   简单工厂模式：根据不同类型返回对应的实例对象（实际中不会使用）
    *   工厂方法：定义一个创建对象的接口，但是由子类决定要实力化的是哪一个，工厂方法让类把实例化推迟到子类
    *   抽象工厂：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类
*   单例模式
    *   特点
        *   保证从系统的启动到系统的终止，全过程只会产生一个实例对象
        *   当我们应用中遇到功能性冲突的时候，需要使用单例模式（判断这个类在多个对象使用时会产生冲突）
    *   7中实现方式
    
*   委派模式
*   策略模式
            
        
