#  分布式基础
##  什么是分布式
##  分布式和集群的关系
### 分布式
*   指一个业务拆分成多个子系统，部署在不同的服务器
### 集群
*   指同一个业务部署在多个服务器上，保证服务高可用

### Session共享问题解决方案
*   session stricky(保证同一个请求地址请求到同一台服务器)
*   session replication
*   session集中存储（db，redis）
*   cookie（userId+token+timestamp）

##  分布式通信协议介绍
### 网络协议TCP/IP和UDP/IP
*   TCP/IP
    +   TCP五层模型：应用层，传输层，链路层，网络层，物理层
    +   OSI七层模型：应用层，传输层，链路层，网络层，物理层，表达层，绘画层
    +   TCP滑动窗口
*   TCP的三次握手和四次挥手
    +   三次握手
    +   四次挥手
*   BIO/NIO

##  分布式通信协议-序列化
*   什么是序列化和反序列化
    +   序列化：把对象转化为字节序列的过程称为序列化
        +   注意点：序列化不保存静态变量的状态 @See UserTest.testStaticVariable()
        +   如果父类没有序列化，子类序列化了，则在序列化是，父类的属性会无法序列化（但是不糊报错）
    +   反序列化：把字节序列转化为对象的过程称为反序列化
    +   序列号的作用：能够保证序列化好反序列化的是同一个对象，如果序列化和反序列化的版本好不一致则会报错
    +   序列化的存储规则：如果对同一个对象进行多次序列化，序列化文件的大小不是翻倍，而是只会在序列化文件中多增加一个引用（这个引用的大小是5个字节）
*   @Transient:忽略序列化@See UserTest.testSerializable()
*   序列化保存方式：可以存储到硬盘或内存
*   java的序列化机制，需要实现Serializable接口
*   java的序列化存在的问题
    +   序列化数据结果比较大，传输效率比较低
    +   不能跨语言对接
*   通过序列化实现克隆（深克隆，浅克隆）todo
    +   深克隆：通过序列化和反序列化实现
    +   浅克隆:实现Cloneable接口，调用clone方法即可
*   目前主流的序列化
    +   JSON/hession/xml/protobuf/kryo/msgpack/fst/thrift/protostuff
    +   Protobuf非常适合网络传输，因为序列化后的字节数小,效率高
*   总结
    +   在java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化
    +   通过ObjectOutputStream和ObjectInputStream对对象进行序列化和反序列化
    +   对象是否允许被反序列化，不仅仅是取决于对象的代码是否一直，同时还有一个重要的因素就是serializableVersionUID
    +   序列化不保存静态变量
    +   要想父类对象也参与序列化操作，需要父类也实现java.io.Seriabliable接口
    +   Transient关键字，主要控制变量是否能够被序列化，如果没有被序列化的成功变量反序列化后，会被设置为初始值
    +   通过序列化方式实现深度克隆
##  分布式通信协议值http协议
*   客户端---->服务端
*   资源
    +   html/文本，媒体
*   媒体类型
    +   Mime类型,text/html,image/jpeg
*   url和uri
    +   uri：web服务器资源的名字。
*   请求方法：get/post/put/delete/patch
*   状态码说明
    +   1xx：提示信息
    +   2xx：成功信息
    +   3xx：重定向
    +   4xx：客户端错误
    +   5xx：服务端错误
*   http协议的特点
    +   无状态：指http请求之间没有任何依赖关系，完全独立
    +   多次请求
    +   基于tcp协议
*   https
    +   概念：http加密协议，加密方式ssl（security socket layer）/tls
    +   https工作原理
        +   加密的问题
            +  
        +   密钥是公开的，所有的客户端都可以拿到
        +   针对不同的客户端使用不同的密钥
        +   使用非对称加密
            1.	服务器端把公钥发送给每一个客户端
            2.	服务器端把公钥放到远程服务器，客户端可以请求到
            3.	让浏览器保存所有的公钥（不现实）
        +   公钥被调包的问题按照上面的方案，永远存在。
        +   使用第三方机构来解决
            +   通过第三方机构，使用第三方机构的私钥对我们【需要传输的公钥】进行加密
        +   数字证书包含的内容
            +   公司信息，网站信息等
            +   每个客户端都会维护一个受信任的证书列表
-----------------
![客户端和服务端证书授权过程](./images/http协议授权原理.png '授权过程说明')

*   RestFul的最佳设计
    +   域名:http://api.rd.com
    +   版本：http://api.rd.com/v1
    +   路径：http://api.rd.com/v1/users-list,http://api.rd.com/v1/user/1
    +   过滤信息：http://api.rd.com/v1/users-list?age=10
    +   状态码
        +   业务状态码
        +   http状态码
*   总结
    +   分布式架构的定义和分布式架构的演进、
    +   分布式架构和集群的区别
    +   TCP/UDP。全双工，半双工，单通信，3次握手，四次挥手
        +   三次握手
            +   客户端发送一个序列号到服务端，确认客户端要链接服务端
            +   服务端对序列号进行加一进行返回给客户端，告诉客户端可以链接
            +   客户端向服务端确认已经收到ack，并开始建立链接
        +   四次挥手
            +   客户端发送FIN标示的报文给到server端
            +   服务端接收到FIN标示后，标示客户端没有数据要发送给服务端了
            +   服务端生成一个随机Ack号给到客户端，服务端Time_wait后关闭链接
            +   客户端接收到服务端接收到Ack的报文，表示服务端没有数据要发送给服务端了。客户端Time_wait后关闭链接
    +   http和https协议，restful规范
        +   客户端发起一个https请求
            +   客户端支持的加密方式
            +   客户端生成的随机数（第一个随机数）
        +   服务端收到请求后
            +   返回证书，或者提示客户端下载证书。
            +   生成一个随机数，返回给客户端（第二个随机数）
        +   客户端拿到证书后开始进行验证
            +   根据办法机构找到本地的根证书
            +   根据ca得到根证书，通过公钥对数字签名解密，得到证书的内容摘要
            +   用证书提供的算法对证书内容解密，获取到摘要内容
            +   通过前两步的对比，也就是验证数字签名
        +   验证通过后，生成一个随机数（第三个随机数），通过证书内的公钥对这个随机数进行加密，发送给服务端
        +   （随机数1+2+3）通过对称加密得到一个密钥（会话密钥）
        +   通过会话密钥对内容进行对称加密传输
        
##  分布式通信框架rmi(现在用得较少了)
*   什么是rmi
*   RPC协议，其实是一个规范。dubbo,thrift,rmi,webservice,hessain
*   特点
    +   网络协议和网络IO对于调用端和服务点来说透明
    +   
*   自己做rpc应该包含的要素
    +   客户端
        +  RPC proxy
        + message protocol
        +  Transfer -tcp/udp ..
    +   服务端
        +  processor
        +  message protocol
        +  Transfer -tcp/udp ...
*  如何实现一个RMI程序
    *   第一步：创建远程接口，并切集成java.rmi.Remote接口
    *   实现远程接口，并集成UnicastRemoteObject
    *   创建服务器程序，LocateRegistry的.createRegistry注册服务并绑定端口
    *   通过Naming.bind("rmi://localhost:8888/test/rmi",rmiService);设置请求路由和端口
    *   编写客户端程序，通过Naming.lookup("rmi://localhost:8888/test/rmi")获取请求端服务接口，然后调用指定方法。这就完成了rmi程序的远程调用
*   自己实现rmi程序的步骤（数据都需要序列化才能进行网络传输）
    *   编写服务器程序，暴露一个监听，可以使用socket
    *   编写客户端程序，通过ip和端口链接到指定的服务器，并将数据进行封装（序列化）
    *   服务端接收到数据后进行数据的反序列化，返回在将数据序列化后返回，这就完成了自己的rmi服务




















    
