#  分布式基础
##  什么是分布式
##  分布式和集群的关系
### 分布式
*   指一个业务拆分成多个子系统，部署在不同的服务器
### 集群
*   指同一个业务部署在多个服务器上，保证服务高可用

### Session共享问题解决方案
*   session stricky(保证同一个请求地址请求到同一台服务器)
*   session replication
*   session集中存储（db，redis）
*   cookie（userId+token+timestamp）

##  分布式通信协议介绍
### 网络协议TCP/IP和UDP/IP
*   TCP/IP
    +   TCP五层模型：应用层，传输层，链路层，网络层，物理层
    +   OSI七层模型：应用层，传输层，链路层，网络层，物理层，表达层，绘画层
    +   TCP滑动窗口
*   TCP的三次握手和四次挥手
    +   三次握手
    +   四次挥手
*   BIO/NIO

##  分布式通信协议-序列化
*   什么是序列化和反序列化
    +   序列化：把对象转化为字节序列的过程称为序列化
        +   注意点：序列化不保存静态变量的状态 @See UserTest.testStaticVariable()
        +   如果父类没有序列化，子类序列化了，则在序列化是，父类的属性会无法序列化（但是不糊报错）
    +   反序列化：把字节序列转化为对象的过程称为反序列化
    +   序列号的作用：能够保证序列化好反序列化的是同一个对象，如果序列化和反序列化的版本好不一致则会报错
    +   序列化的存储规则：如果对同一个对象进行多次序列化，序列化文件的大小不是翻倍，而是只会在序列化文件中多增加一个引用（这个引用的大小是5个字节）
*   @Transient:忽略序列化@See UserTest.testSerializable()
*   序列化保存方式：可以存储到硬盘或内存
*   java的序列化机制，需要实现Serializable接口
*   java的序列化存在的问题
    +   序列化数据结果比较大，传输效率比较低
    +   不能跨语言对接
*   通过序列化实现克隆（深克隆，浅克隆）todo
    +   深克隆：通过序列化和反序列化实现
    +   浅克隆:实现Cloneable接口，调用clone方法即可
*   目前主流的序列化
    +   JSON/hession/xml/protobuf/kryo/msgpack/fst/thrift/protostuff
    +   Protobuf非常适合网络传输，因为序列化后的字节数小,效率高
*   总结
    +   在java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化
    +   通过ObjectOutputStream和ObjectInputStream对对象进行序列化和反序列化
    +   对象是否允许被反序列化，不仅仅是取决于对象的代码是否一直，同时还有一个重要的因素就是serializableVersionUID
    +   序列化不保存静态变量
    +   要想父类对象也参与序列化操作，需要父类也实现java.io.Seriabliable接口
    +   Transient关键字，主要控制变量是否能够被序列化，如果没有被序列化的成功变量反序列化后，会被设置为初始值
    +   通过序列化方式实现深度克隆
##  分布式通信协议值http协议
*   客户端---->服务端
*   资源
    +   html/文本，媒体
*   媒体类型
    +   Mime类型,text/html,image/jpeg
*   url和uri
    +   uri：web服务器资源的名字。
*   请求方法：get/post/put/delete/patch
*   状态码说明
    +   1xx：提示信息
    +   2xx：成功信息
    +   3xx：重定向
    +   4xx：客户端错误
    +   5xx：服务端错误
*   http协议的特点
    +   无状态：指http请求之间没有任何依赖关系，完全独立
    +   多次请求
    +   基于tcp协议
*   https
    +   概念：http加密协议，加密方式ssl（security socket layer）/tls
    +   https工作原理
        +   加密的问题
            +  
        +   密钥是公开的，所有的客户端都可以拿到
        +   针对不同的客户端使用不同的密钥
        +   使用非对称加密
            1.	服务器端把公钥发送给每一个客户端
            2.	服务器端把公钥放到远程服务器，客户端可以请求到
            3.	让浏览器保存所有的公钥（不现实）
        +   公钥被调包的问题按照上面的方案，永远存在。
        +   使用第三方机构来解决
            +   通过第三方机构，使用第三方机构的私钥对我们【需要传输的公钥】进行加密
        +   数字证书包含的内容
            +   公司信息，网站信息等
            +   每个客户端都会维护一个受信任的证书列表
-----------------
![客户端和服务端证书授权过程](./images/http协议授权原理.png '授权过程说明')

*   RestFul的最佳设计
    +   域名:http://api.rd.com
    +   版本：http://api.rd.com/v1
    +   路径：http://api.rd.com/v1/users-list,http://api.rd.com/v1/user/1
    +   过滤信息：http://api.rd.com/v1/users-list?age=10
    +   状态码
        +   业务状态码
        +   http状态码
*   总结
    +   分布式架构的定义和分布式架构的演进、
    +   分布式架构和集群的区别
    +   TCP/UDP。全双工，半双工，单通信，3次握手，四次挥手
        +   客户端发送FIN标示的豹纹给到server端
        +   服务端接收到FIN标示后，标示客户端没有数据要发送给服务端了，并生成一个随机seq号给到客户端
        +   客户端接收到服务端接收到Ack的报文，表示服务端没有数据要发送给服务端了。并准备关闭链接
    +   
        
##  分布式通信框架rmi(现在用得较少了)
*   


    
