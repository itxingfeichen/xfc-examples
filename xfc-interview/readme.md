*   类加载顺序
    *   从父到子，静态先行，静态只加载一遍
    *   静态代码块->普通代码块->构造方法
*   方法覆盖问题
    *   子类是否允许抛出比父类更大的异常？
        *   不能 ：因为子类在覆盖父类的方法时，因为父类的引用可以调用子类的方法，则会导致子类抛出的异常时父类不能处理
    *   子类的修饰符权限是否比父类更大？
        *   可以：子类的修饰符权限只能大于或等于父类，如果子类权限小于父类，将会报错
*   集合类
    *   HashMap
    *   HashSet：底层HashMap，add进去的元素为key，value固定为PRESENT ，即Object对象    
    *   ArrayList/LinkedList/Vector区别？谈谈你的理解
        *   ArrayList底层是什么？扩容机制是什么？
            *   底层为Object数组，默认容量为10，容量不够时会调用grow方法通过Arrays.copyOf进行扩容
        *   ArrayList和Vector最大的区别？
            *   两者底层数据结构一致，最大的区别是Vector是强同步的，相关方法都被synchronized进行修饰，效率较低
            *   前者扩容时是扩1.5倍，后者扩容2倍
        *   ArrayList和LinkedList最大的区别？
            *   ArrayList使用动态数组实现，LinkedList链表实现
            *   随机数据访问，ArrayList可以直接访问指定角标元素，LinkedList需要移动指针，因此ArrayList具有优势
            *   数据添加，删除，ArrayList需要移动数据，LinkedList直接连接前后指针即可，因此LinkedList具有优势
*   java8特性
    *   lambda
    *   函数式接口 @FunctionalInterface
    *   接口中可以增加方法实现default方法
    *   HashMap数据结构
*   线程
    *   五种线程状态
        *   NEW
        *   RUNNABLE
        *   BLOCKED
        *   WAITING
        *   TIME_WAITING
        *   TERMINATED
*   wait和notify
    *   虚假唤醒，多线程需要使用while判断
    *   线程间通信
*   wait和sleep区别
    *   wait等待后释放锁，sleep不会释放锁
*   synchronized
    *   一个对象如果有多个synchronized方法，某一时刻，只要一个线程去调用其中synchronized方法，其他的线程都只能等待
        锁的是当前对象this，被锁定后，其他的线程都不能进入到当前对象的其他synchronized方法
    *   所有的静态同步方法用的也是同一把是，即Class对象
    
*   分布式 消息队列
    *    rabbitmq
        *   介绍：消息队列功能完善，吞吐量万级（相对而言，取决于服务器配置）。社区活跃度高，版本迭代快，后台管理功能完善易用
                 基于erlang语言开发。
        *   rabbitmq的三种集群模式
            *   单机模式
            *   普通集群模式：数据均存储在一个节点，其他节点仅仅存储队列元信息
                *   优点：单个节点处理能力高
                *   缺点：(1)如果数据量大，会导致集群内部会有大量数据传输 (2)无法做到高可用，一旦储存数据的节点崩溃，则整个集群崩溃
            *   镜像集群模式：每个节点都保存队列的完成信息，含元信息和数据
                *   优点：任意一个节点宕机不影响数据，因为每个节点都包含了完整数据
                *   缺点：所有的节点数据都一致，如果rabbitmq内数据过多，有可能导致服务器磁盘不够用，但如果真到这时候，就应该衡量一下是对系统数据量评估不足，还是服务器磁盘真的不够
                *   开启镜像集群模式的方法：需要在rabbitmq后台配置集群策略 ？？
    *   kafka
        *   介绍：kafka是一个纯分布式消息队列，功能简单，但是吞吐量高十万级别，适合大数据日志采集。通过配置和优化可以做到消息零丢失
                kafka是一个分布式消息队列。具有高性能、持久化、多副本备份、横向扩展能力。生产者往队列里写消息，消费者从队列里取消息进行业务逻辑。一般在架构设计中起到解耦、削峰、异步处理的作用
        *   如何保证高可用
            *   集群之间通过保留消息副本的方式
            *   kafka内的节点叫做broker
    *   如何避免消息被重复消费（幂等问题），常见解决方案？
        *   分布式锁，记录消费流水
        *   redis的set集合记录消费记录
        *   数据库唯一索引
        *   数据库悲观锁
        *   token机制
