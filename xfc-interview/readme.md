*   类加载顺序
    *   从父到子，静态先行，静态只加载一遍
    *   静态代码块->普通代码块->构造方法
*   方法覆盖问题
    *   子类是否允许抛出比父类更大的异常？
        *   不能 ：因为子类在覆盖父类的方法时，因为父类的引用可以调用子类的方法，则会导致子类抛出的异常时父类不能处理
    *   子类的修饰符权限是否比父类更大？
        *   可以：子类的修饰符权限只能大于或等于父类，如果子类权限小于父类，将会报错
*   集合类
    *   HashMap
    *   HashSet：底层HashMap，add进去的元素为key，value固定为PRESENT ，即Object对象    
    *   ArrayList/LinkedList/Vector区别？谈谈你的理解
        *   ArrayList底层是什么？扩容机制是什么？
            *   底层为Object数组，默认容量为10，容量不够时会调用grow方法通过Arrays.copyOf进行扩容
        *   ArrayList和Vector最大的区别？
            *   两者底层数据结构一致，最大的区别是Vector是强同步的，相关方法都被synchronized进行修饰，效率较低
            *   前者扩容时是扩1.5倍，后者扩容2倍
        *   ArrayList和LinkedList最大的区别？
            *   ArrayList使用动态数组实现，LinkedList链表实现
            *   随机数据访问，ArrayList可以直接访问指定角标元素，LinkedList需要移动指针，因此ArrayList具有优势
            *   数据添加，删除，ArrayList需要移动数据，LinkedList直接连接前后指针即可，因此LinkedList具有优势
*   java8特性
    *   lambda
    *   函数式接口 @FunctionalInterface
    *   接口中可以增加方法实现default方法
    *   HashMap数据结构
*   线程
    *   五种线程状态
        *   NEW
        *   RUNNABLE
        *   BLOCKED
        *   WAITING
        *   TIME_WAITING
        *   TERMINATED
*   wait和notify
    *   虚假唤醒，多线程需要使用while判断
    *   线程间通信
*   wait和sleep区别
    *   wait等待后释放锁，sleep不会释放锁
*   synchronized
    *   一个对象如果有多个synchronized方法，某一时刻，只要一个线程去调用其中synchronized方法，其他的线程都只能等待
        锁的是当前对象this，被锁定后，其他的线程都不能进入到当前对象的其他synchronized方法
    *   所有的静态同步方法用的也是同一把是，即Class对象
    
*   分布式 消息队列
    *    rabbitmq
        *   介绍：消息队列功能完善，吞吐量万级（相对而言，取决于服务器配置）。社区活跃度高，版本迭代快，后台管理功能完善易用
                 基于erlang语言开发。
        *   rabbitmq的三种集群模式
            *   单机模式
            *   普通集群模式：数据均存储在一个节点，其他节点仅仅存储队列元信息
                *   优点：单个节点处理能力高
                *   缺点：(1)如果数据量大，会导致集群内部会有大量数据传输 (2)无法做到高可用，一旦储存数据的节点崩溃，则整个集群崩溃
            *   镜像集群模式：每个节点都保存队列的完成信息，含元信息和数据
                *   优点：任意一个节点宕机不影响数据，因为每个节点都包含了完整数据
                *   缺点：所有的节点数据都一致，如果rabbitmq内数据过多，有可能导致服务器磁盘不够用，但如果真到这时候，就应该衡量一下是对系统数据量评估不足，还是服务器磁盘真的不够
                *   开启镜像集群模式的方法：需要在rabbitmq后台配置集群策略 ？？
    *   kafka
        *   介绍：kafka是一个纯分布式消息队列，功能简单，但是吞吐量高十万级别，适合大数据日志采集。通过配置和优化可以做到消息零丢失
                kafka是一个分布式消息队列。具有高性能、持久化、多副本备份、横向扩展能力。生产者往队列里写消息，消费者从队列里取消息进行业务逻辑。一般在架构设计中起到解耦、削峰、异步处理的作用
        *   如何保证高可用
            *   集群之间通过保留消息副本的方式
            *   kafka内的节点叫做broker
    *   如何避免消息被重复消费（幂等问题），常见解决方案？
        *   分布式锁，记录消费流水
        *   redis的set集合记录消费记录
        *   数据库唯一索引
        *   数据库悲观锁
        *   token机制
    *   分布式事务
        *   分布式事务了解嘛？你们是如何解决分布式事务问题的？
            *   XA方案（两阶段提交）：Spring + JTA，性能较低，违反微服务架构方案，应用程序会连接多个数据源
                *   第一阶段：准备提交 preparedCommit
                *   第二阶段：提交事务/回滚 doCommit/rollback
                *   缺点：算法执行过程中，所有节点都处于阻塞状态，所有节点所持有的资源（例如数据库数据，本地文件等）都处于封锁状态
                         需要维护事务管理服务，事务服务的宕机问题，整个事务的执行需要由协调者在多个节点之间去协调，增加了事务的执行时间，性能低下
                *   优点：实现强一致性，部分关系数据库支持
            *   事务补偿TCC方案 Try Confirm Cancel
                *   Try：下单业务由订单服务和库存服务协同完成，在try阶段订单服务和库存服务完成检查和预留资源。
                        订单服务检查当前是否满足提交订单的条件（比如：当前存在未完成订单的不允许提交新订单）。
                        库存服务检查当前是否有充足的库存，并锁定资源。
                *   Confirm：订单服务和库存服务成功完成Try后开始正式执行资源操作。
                            订单服务向订单写一条订单信息。
                            库存服务减去库存。
                *   Cancel：如果订单服务和库存服务有一方出现失败则全部取消操作。
                           订单服务需要删除新增的订单信息。
                           库存服务将减去的库存再还原。
                *   优点：最终保证数据的一致性，在业务层实现事务控制，灵活性好
                *   缺点：开发成本高，代码负责，每个事务操作每个参与者都需要实现try/confirm/cancel三个接口。
                *   注意：TCC的try/confirm/cancel接口都要实现幂等性，在为在try、confirm、cancel失败后要不断重试。
            *   本地消息列表
                *   优点：由MQ按异步的方式协调完成事务，性能较高
                *   缺点：此方式基于关系数据库本地事务来实现，会出现频繁读写数据库记录，浪费数据库资源，另外对于高并发操作不是最佳方案
                *   依赖于本地消息表，如A系统处理完数据以后保存一条消息，修改为处理中状态或者待通知状态，然后发送消息给B系统，如果B系统处理完成，通知A系统处理成功或处理失败，然后A系统自己更新本次处理状态
            *   最大努力通知型
                *   允许少数事务失败
                *   系统A本地事务执行完之后，发送个消息到MQ
                *   这里会有个专门消费MQ的最大努力通知服务，这个服务会消费MQ，然后写入数据库中记录下来，或者是放入个内存队列。接着调用系统B的接口
                    假如系统B执行成功就万事ok了，但是如果系统B执行失败了呢？
                *   那么此时最大努力通知服务就定时尝试重新调用系统B，反复N次，最后还是不行就放弃。
            *   最终一致性（RocketMQ）
                *   数据最终一致
        *   你们公司如何处理分布式事务   
            *   严格比如扣款操作使用TCC
            *   非严格的采用的最终一致性
    *   https://www.w3cschool.cn/architectroad/architectroad-optimization-of-seckilling-system.html
