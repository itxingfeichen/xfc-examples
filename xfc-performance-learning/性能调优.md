#   性能调优
##  性能调优基础
### 什么是性能调优
*   合理充分利用服务起的资源
*   调优方向
    *   CPU步骤
        *   通过top命令查看cpu情况，找到占用资源最高的进程ID（java进程）
        *   通过top -H -p pid
        *   将进程id转换为是十六进制，通过命令 printf '%x' 线程id
        *   通过jdk自带的工具jstack -l pid >> /tmp/error.log
        *   搜索第三部打印出来的十六进制数据，即可定位到指定的耗cpu的线程，既可以定位到指定的代码
    *   Memory
    *   IO
    *   
*   监控实现
    +   www.zipkin.io
    +   cat
##  jvm调优
*   jvm参数调优
    *   X代表非标准参数
    *   XX代表非标准并且不保证稳定性的参数
    *   XX-/XX+代表布尔类型的参数
*   jvm垃圾回收的条件
    *   
*   jvm垃圾回收算法
    *   标记清楚算法
    *   可达性分析分
    *   标记整理算法
*   jvm垃圾收集器
    *   垃圾收集器是垃圾回收算法的实现
        ![垃圾收集器](./images/垃圾收集器.jpg '垃圾收集器')
    *   
##  tomcat
###   tomcat目录介绍
####   conf目录
*   `catalina.policy`:tomcat安全策略文件，控制jvm相关权限，具体参考`java.seurity.Permission`
*   `catalina.properties`:tomcat Catclina行为控制配置文件，比如common ClassLoader
*   `logging.properties`:tomcat日志配置文件，jdk logging
*   `server.xml`:tomcat服务配置
    *   `GlobalNamingResources`:全局JNDI资源
*   `tomcat-user.xml`:tomcat角色权限配置文件，realm文件实现方式
*   `context.xml`: 全局配置文件
*   `web.xml`:servlet标准的web.xml部署文件。tomcat默认实现部分配置
    *   `DefaultServlet`
    *   `JspServlet`
####    lib目录
*   tomcat存放公共目录的包
    *   `ecj-*.jar`:eclipse java编译器
    *   `jasper.jar`:jsp编译器
    *   其他自行了解
####    logs目录
*   `localhost.${date}.log`:当tomcat应用起不来的时候，多看该文件。如：NoClassDefiniedException
*   `catalina.${date}.log`:控制台输出，`System.setOut()`外置
####    webapps目录
*   一般不会直接把包放近webapps目录下，一般建议外置（比较专业的用法）

### 嵌入式tomcat
####    web技术栈
####    Servlet技术栈
####    webflux（netty） 
####    tomcat配置调优
*   配置简化
    *   场景一
        *   当前应用rest应用（微服务）
            *   分析：它不需要静态资源，tomcat容器包含静态和动态
                *   静态处理：`DefaultServlet`
                *   动态：应用Servlet，`JspServlet`
                *   优化方案：通过移除`conf/web.xml`中的`JspServlet`减少tomcat加载项
            *   Spring WebMVC 应用Servlet：`DisPatcherServlet`
                +   JspServlet:比那一并且执行jsp页面
                +  DefaultServlet:tomcat默认加载静态资源的servlet
                +   移除 welcome-filelist
                +   如果程序是rest json Content-type或者Mime type；application/json
                +   移除session设置
                    +   对于微服务来讲，不需要保持会话内容，可以进行移除session的设置
                +   移除Valve（类似于filter）
                    +   移除`AccessLogValve`，可以通过nginx的accessLog替代，Valve实现需要消耗java应用的计算空间
        *   需要使用jsp的情况
            *   分析：jsp的使用方法，了解servlet处理原理
            >  servlet周期
            *   实例化：serlet或者filter初始化必须包含默认构造器
            *   初始化：servlet容器会调用servlet的init方法
            *   销毁：
            *   面试点：servlet是单例嘛？不一定，看使用者如何使用，对同一个servlet起多个名称就会是多个对象   
            *   Jsp相关的参数优化
                +   需要编译
                    +   compiler
                    +   modificationTestInternal
                    +   编译优化方法
                        +   插件
                            +   ant task进行jsp编译
                            +   maven插件编译
                                ```xml
                                      <dependency>
                                          <groupId>org.springframework.boot</groupId>
                                          <artifactId>spring-boot-starter-web</artifactId>
                                          <version>2.1.3.RELEASE</version>
                                      </dependency>        
                +   不需要编译
                    +   development:设置为false
                +  
        *   总结
            +   conf/xml作为Servlet应用的默认配置，实际上，应用存在两份web.xml，其中包括tomcat的conf/web.xml和应用的web.xml，最终两者会进行合并
            +   jspServlet如果development参数设置为true，它会自动检查文件是否修改，如果修改重新翻译，再进行编译（加载和执行，init和preCompiler）。言外之意，jspServlet开发模式可能会导致oom，卸载class不及时锁知道perm区域不够  
            +   如何卸载一个class
                +   class需要被卸载，需要将指定的classLoader设置为null，这样的化classLoader被GC后，它加载的类都会被进行卸载
                +   类加载机制
*   配置调整
    +   关闭自动重载（默认是true）
        <Context xxx reloadable=false/>
        ```xml
            <welcome-file-list>
                  <welcome-file>index.html</welcome-file>
                  <welcome-file>index.htm</welcome-file>
                  <welcome-file>index.jsp</welcome-file>
              </welcome-file-list>
    +   修改连接线程池的数量
        +   ```xml
              <Connector executor="tomcatThreadPool"
                             port="8080" protocol="HTTP/1.1"
                             connectionTimeout="20000"
                             redirectPort="8443" />
              <Executor name="tomcatThreadPool" namePrefix="catalina-exec-" maxThreads="150" minSpareThreads="4"/>
    +   性能评估的参考（可以通过jmeter进行测试）
        +   正确率
        +   load（cpu->jvm gc）
        +   CPU密集型
        +   IO密集型，网络，文件读写    
    +   如何评估一个系统设置多少线程数合适（这个需要测试）
        +   首先评估整体的请求量
        +   进行压力测试（样本采集），jmeter实现，1000个线程进行请求，观察吞吐量，以及消耗时间
        +   常规性雅策
*   预编译优化
####    jvm优化
*   调整gc算法
    *   java版本小于9，默认PS mark sweep,可选设置cms，G1
    *   java9以后，默认就是G1
    *   调整堆大小
    *   修改默认GC
    *   -server主要提高吞吐量，在有限的资源下，充分利用资源。-client主要提高响应时间，主要用于提高用户体验
*   springboot参数配置
    *   `org.springframework.boot.autoconfigure.web.ServerProperties`
    *   `org.springframework.boot.autoconfigure.web.ResourceProperties`
    ![tomcat优化配置](./images/springboot配置.jpg 'tomcat优化配置')

        
        
